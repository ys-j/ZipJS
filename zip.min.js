const U=Uint8Array,V=DataView,crc32table=Uint32Array.from({length:256},((e,t)=>{let s=t,i=8;for(;i--;)s=1&s?3988292384^s>>>1:s>>>1;return s}));export const calcCrc32=e=>{let t=4294967295;for(const s of e)t=crc32table[255&(t^s)]^t>>>8;return 4294967295^t};export const fmtCrc32=e=>[24,16,8,0].map((t=>e>>>t&255)).map((e=>e.toString(16).padStart(2,"0"))).join("").toUpperCase();export class Extractor{eocd;cd;contents;constructor(e){const t=new U(e).findLastIndex(((e,t,s)=>[80,75,5,6].every(((e,i)=>e===s[t+i]))));if(t<0)throw new Error("Invalid format: End of central directory record is not found.");this.eocd=EndOfCentralDirectoryRecord.from(new V(e,t));let s=this.eocd.cdOffset;this.cd=Array.from({length:this.eocd.numOfFiles},(()=>{const i=new V(e,s,t-s),n=CentralDirectoryEntry.from(i);return s+=n.length,n})),this.contents=this.cd.map((t=>{const s=new V(e,t.headerOffset),i=LocalFileHeader.from(s);let n=i.length;if(i.hasDataDescriptor){const e=s.getUint32(n+=4,!0);i.crc32=134695760===e?s.getUint32(n+=4):e,i.compressedSize=s.getUint32(n+=4),i.uncompressedSize=s.getUint32(n+=4)}return{header:i,body:new U(s.buffer,n+s.byteOffset,t.compressedSize)}}))}pick(e){const t=this.contents.at(e);if(!t){throw new Error("No content at the index: "+e)}const s=new Blob([t.body]).stream();switch(t.header.method){case 0:return new Response(s);case 8:const e=new DecompressionStream("deflate-raw");return new Response(s.pipeThrough(e));default:const i="Unsupported compression method: "+t.header.method;throw new Error(i)}}getNames(e){const t=new TextDecoder(e);return this.cd.map((e=>t.decode(e.fileNameBytes)))}*[Symbol.iterator](){for(let e=0;e<this.contents.length;e++)yield{entry:this.cd[e],header:this.contents[e].header,body:this.pick(e)}}}export class Builder{static textDecoder=new TextDecoder;static textEncoder=new TextEncoder;centralDirectory=[];contents=[];async append(e,t){const s=new U(e),i="string"==typeof t?{filepath:t}:t,n=new CentralDirectoryEntry,r=new LocalFileHeader,o=i.method??8;n.versionNeeded=r.versionNeeded=8===o?20:10,n.versionMadeBy=20,n.method=r.method=o,n.lastModified=r.lastModified=ZipDateTime.fromDate(i.lastModified?new Date(i.lastModified):new Date),n.isUtf8=r.isUtf8=!0;const a=Builder.textEncoder.encode(i.filepath);switch(n.fileNameBytes=r.fileNameBytes=a,n.extraFieldBytes=r.extraFieldBytes=i.extraField??new U,n.commentBytes=Builder.textEncoder.encode(i.comment),n.crc32=r.crc32=calcCrc32(s),n.uncompressedSize=r.uncompressedSize=s.length,o){case 0:return n.compressedSize=r.compressedSize=s.length,this.centralDirectory.push(n),this.contents.push({header:r,body:s});case 8:const e=new Blob([s]).stream(),t=new CompressionStream("deflate-raw"),i=new Response(e.pipeThrough(t)),a=await i.bytes();return n.compressedSize=r.compressedSize=a.length,this.centralDirectory.push(n),this.contents.push({header:r,body:a});default:throw new Error("Unsupported compression method: "+o)}}remove(e,t=1){const s=this.centralDirectory.splice(e,t);return this.contents.splice(e,1),s.map((e=>Builder.textDecoder.decode(e.fileNameBytes)))}build(e){const t=[];let s=0;const i=this.contents.length;for(let e=0;e<i;e++){this.centralDirectory[e].headerOffset=s;const{header:i,body:n}=this.contents[e],r=i.toBlobParts();t.push(...r,n),s+=r.reduce(((e,t)=>e+t.byteLength),0)+n.length}const n=this.centralDirectory.flatMap((e=>e.toBlobParts()));t.push(...n);const r=new EndOfCentralDirectoryRecord;return r.numOfFiles=i,r.totalNumOfFiles=i,r.cdSize=n.reduce(((e,t)=>e+t.byteLength),0),r.cdOffset=s,r.commentBytes=Builder.textEncoder.encode(e?.comment),t.push(...r.toBlobParts()),new Blob(t,{type:"application/zip"})}}class ZipDateTime{year;month;day;hour;minute;second;toInt(){return(this.year-1980<<25)+(this.month<<21)+(this.day<<16)+(this.hour<<11)+(this.minute<<5)+Math.floor(this.second/2)}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}static fromInt(e){const t=new ZipDateTime;return t.year=1980+(e>>>25),t.month=e>>>21&15,t.day=e>>>16&31,t.hour=e>>>11&31,t.minute=e>>>5&63,t.second=2*(31&e),t}static fromDate(e=new Date){const t=new ZipDateTime;return t.year=e.getFullYear(),t.month=e.getMonth()+1,t.day=e.getDate(),t.hour=e.getHours(),t.minute=e.getMinutes(),t.second=e.getSeconds(),t}}class LocalFileHeader{signature=67324752;versionNeeded=20;flags=1024;method=8;lastModified=ZipDateTime.fromDate();crc32=0;compressedSize=0;uncompressedSize=0;fileNameBytes;extraFieldBytes;length;static from(e){const t=new LocalFileHeader;t.signature=e.getUint32(0,!0),t.versionNeeded=e.getUint16(4,!0),t.flags=e.getUint16(6,!0),t.method=e.getUint16(8,!0),t.lastModified=ZipDateTime.fromInt(e.getUint32(10,!0)),t.crc32=e.getUint32(14,!0),t.compressedSize=e.getUint32(18,!0),t.uncompressedSize=e.getUint32(22,!0);const s=e.getUint16(26,!0),i=e.getUint16(28,!0),n=e.byteOffset+30;return t.fileNameBytes=new U(e.buffer,n,s),t.extraFieldBytes=new U(e.buffer,n+s,i),t.length=30+s+i,t}toBlobParts(){const e=new V(new ArrayBuffer(30));return e.setUint32(0,this.signature,!0),e.setUint16(4,this.versionNeeded,!0),e.setUint16(6,this.flags,!0),e.setUint16(8,this.method,!0),e.setUint32(10,this.lastModified.toInt(),!0),e.setUint32(14,this.crc32,!0),e.setUint32(18,this.compressedSize,!0),e.setUint32(22,this.uncompressedSize,!0),e.setUint16(26,this.fileNameBytes.length,!0),e.setUint16(28,this.extraFieldBytes.length,!0),[e,this.fileNameBytes,this.extraFieldBytes]}getFlag(e){return 1==(this.flags>>e&1)}setFlag(e,t){const s=1<<e;t?this.flags|=s:this.flags&=~s}get isEncrypted(){return this.getFlag(0)}set isEncrypted(e){this.setFlag(0,e)}get hasDataDescriptor(){return this.getFlag(3)}set hasDataDescriptor(e){this.setFlag(3,e)}get isEnhancedDeflating(){return this.getFlag(4)}set isEnhancedDeflating(e){this.setFlag(4,e)}get isCompressedPatchedData(){return this.getFlag(5)}set isCompressedPatchedData(e){this.setFlag(5,e)}get isEncryptedStrongly(){return this.getFlag(6)}set isEncryptedStrongly(e){this.setFlag(6,e)}get isUtf8(){return this.getFlag(11)}set isUtf8(e){this.setFlag(11,e)}get isCentralDirectoryEncrypted(){return this.getFlag(13)}set isCentralDirectoryEncrypted(e){this.setFlag(13,e)}}class CentralDirectoryEntry extends LocalFileHeader{signature=33639248;versionMadeBy=20;diskIdStart=0;internalAttributes=0;externalAttributes=0;headerOffset;commentBytes;static from(e){const t=new CentralDirectoryEntry;t.signature=e.getUint32(0,!0),t.versionMadeBy=e.getUint16(4,!0),t.versionNeeded=e.getUint16(6,!0),t.flags=e.getUint16(8,!0),t.method=e.getUint16(10,!0),t.lastModified=ZipDateTime.fromInt(e.getUint32(12,!0)),t.crc32=e.getUint32(16,!0),t.compressedSize=e.getUint32(20,!0),t.uncompressedSize=e.getUint32(24,!0);const s=e.getUint16(28,!0),i=e.getUint16(30,!0),n=e.getUint16(32,!0);t.diskIdStart=e.getUint16(34,!0),t.internalAttributes=e.getUint16(36,!0),t.externalAttributes=e.getUint32(38,!0),t.headerOffset=e.getUint32(42,!0);const r=e.byteOffset+46;return t.fileNameBytes=new U(e.buffer,r,s),t.extraFieldBytes=new U(e.buffer,r+s,i),t.commentBytes=new U(e.buffer,r+s+i,n),t.length=46+s+i+n,t}toBlobParts(){const e=new V(new ArrayBuffer(46));return e.setUint32(0,this.signature,!0),e.setUint16(4,this.versionMadeBy,!0),e.setUint16(6,this.versionNeeded,!0),e.setUint16(8,this.flags,!0),e.setUint16(10,this.method,!0),e.setUint32(12,this.lastModified.toInt(),!0),e.setUint32(16,this.crc32,!0),e.setUint32(20,this.compressedSize,!0),e.setUint32(24,this.uncompressedSize,!0),e.setUint16(28,this.fileNameBytes.length,!0),e.setUint16(30,this.extraFieldBytes.length,!0),e.setUint16(32,this.commentBytes.length,!0),e.setUint16(34,this.diskIdStart,!0),e.setUint16(36,this.internalAttributes,!0),e.setUint32(38,this.externalAttributes,!0),e.setUint32(42,this.headerOffset,!0),[e,this.fileNameBytes,this.extraFieldBytes,this.commentBytes]}}class EndOfCentralDirectoryRecord{signature=101010256;diskId=0;firstDiskId=0;numOfFiles=1;totalNumOfFiles=0;cdSize;cdOffset;commentBytes;length;static from(e){const t=new EndOfCentralDirectoryRecord;t.signature=e.getUint32(0,!0),t.diskId=e.getUint16(4,!0),t.firstDiskId=e.getUint16(6,!0),t.numOfFiles=e.getUint16(8,!0),t.totalNumOfFiles=e.getUint16(10,!0),t.cdSize=e.getUint32(12,!0),t.cdOffset=e.getUint32(16,!0);const s=e.getUint16(20,!0),i=e.byteOffset+22;return t.commentBytes=new U(e.buffer,i,s),t.length=22+s,t}toBlobParts(){const e=new V(new ArrayBuffer(22));return e.setUint32(0,this.signature,!0),e.setUint16(4,this.diskId,!0),e.setUint16(6,this.firstDiskId,!0),e.setUint16(8,this.numOfFiles,!0),e.setUint16(10,this.totalNumOfFiles,!0),e.setUint32(12,this.cdSize,!0),e.setUint32(16,this.cdOffset,!0),e.setUint16(20,this.commentBytes.length,!0),[e,this.commentBytes]}}